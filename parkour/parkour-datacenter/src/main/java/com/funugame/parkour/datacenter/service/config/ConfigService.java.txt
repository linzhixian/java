/**
 * 
 */
package com.funugame.parkour.datacenter.service.config;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TimerTask;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.funugame.parkour.api.IConfigService;
import com.funugame.parkour.api.beans.ClientConfig;
import com.funugame.parkour.api.beans.ConfigFile;
import com.funugame.parkour.datacenter.DataCenterServer;
import com.funugame.parkour.datacenter.service.util.ParserConfigUtil;
import com.lzx.framework.server.IServer;
import com.lzx.framework.utils.file.CharSetConvertor;

/**
 * @author linzhixian 2014年10月24日下午2:39:34 classpath:conf/ 下 有： version.txt
 *         配置文件版本号，每当clientNeedFiles.txt自身及其里面的文件有改变都必须改变 clientNeedFiles.txt
 *         客户端需要的配置文件列表
 * 
 */

@Service("configService_RMI")
public class ConfigService extends TimerTask implements IConfigService, InitializingBean {
    protected static Logger logger = LoggerFactory.getLogger(ConfigService.class);

    // 客户端配置文件总版本号，每次客户端文件有修改请增加版本号
    public static String VERSION_FILENAME = "version.txt";
    // 客户配置文件列表
    public static String CLIENT_NEED_FILES_FILENAME = "clientNeedFiles.txt";

    private Map<String, RawFile> configFileMap = new HashMap<String, RawFile>();

    private ClientConfig clientConfig = new ClientConfig();
    @Autowired
    private IServer server;

    private static String dataDir;

    @Override
    public void afterPropertiesSet() throws Exception {
	// 初始化加载：加载version。txt,clientNeedFiles。txt 两文件内容到ClientConfig
	// 启动线程定时检查version的变化，有变化重复上面步骤
	DataCenterServer dServer = (DataCenterServer) server;
	dataDir = dServer.getAppRootDir() + "data" + File.separator;
	File f=new File("");
	System.out.println(f.getAbsolutePath());
	
	loadClientNeedFiles(loadConfigResource("clientNeedFiles.txt"));
	loadAllRawFile();
	// 定时判断是否有配置文件更新，如果还有就重新加载
	dServer.getTimer().schedule(this, 0, 60 * 1000);
    }

    @Override
    public int getVersion() {
	return this.clientConfig.getVersion();
    }

    @Override
    public ClientConfig getClientConfig() {

	return this.clientConfig;
    }

    @Override
    public void run() {
	try {
	    loadAllRawFile();
	} catch (IOException e) {
	    e.printStackTrace();
	}
    }

    private void loadAllRawFile() throws IOException {
	// load version file
	File dir = openFile("");
	// System.err.println(dir.getAbsolutePath());
	if (!dir.isDirectory()) {
	    System.err.println(dir.getParent() + " must a direction");
	    throw new IllegalArgumentException();
	}
	File[] files = dir.listFiles();
	for (File f : files) {
	    if (!f.isFile())
		continue;
	    String fileName = f.getName();
	    RawFile configFile = configFileMap.get(fileName);
	    if (configFile == null || configFile.isNew(f.lastModified())) {
		logger.info("load conf file:" + fileName);
		System.out.println("load conf file:" + fileName);
		configFile = new RawFile(f);
		configFileMap.put(fileName, configFile);
		if (fileName.equals(VERSION_FILENAME)) {
		    loadVersion(configFile.getContent());
		} else if (fileName.equals(CLIENT_NEED_FILES_FILENAME)) {
		    loadClientNeedFiles(configFile.getContent());
		} else {
		    ParserConfigUtil.parserConfigTxt(configFile);
		}
		if (isInClientNeedFile(fileName)) {
		    clientConfig.addConfigFile(fileName, convertToConfigFile(configFile.getContent()));
		}
	    }
	    // 不再使用，清除文件内容，释放内存
	    configFile.setContent(null);
	}
    }

    private ConfigFile convertToConfigFile(String content) {
	ConfigFile cf = new ConfigFile();
	String as[] = org.apache.commons.lang.StringUtils.splitByWholeSeparatorPreserveAllTokens(content, "\r\n");
	String columnNames[] = org.apache.commons.lang.StringUtils.splitByWholeSeparatorPreserveAllTokens(as[1], "\t");
	cf.addColumns(columnNames);
	if (as.length > 2) {
	    for (int i = 2; i < as.length; i++) {
		String datas[] = org.apache.commons.lang.StringUtils.splitByWholeSeparatorPreserveAllTokens(as[i], "\t");
		if (datas.length != 0) {
		    cf.addData(datas);
		}
	    }
	}
	return cf;
    }

    private List<String> clientNeedFiles = new ArrayList<String>();

    private void loadClientNeedFiles(String content) {
	String as1[] = org.apache.commons.lang.StringUtils.splitByWholeSeparator(content, "\r\n");
	for (String s : as1) {
	    clientNeedFiles.add(s);
	}
    }

    private boolean isInClientNeedFile(String name) {
	for (String fName : clientNeedFiles) {
	    if (name.equals(fName))
		return true;
	}
	return false;
    }

    private void loadVersion(String content) {
	this.clientConfig.setVersion(Integer.parseInt(content.trim()));
	System.out.println("set Version:" + content);
    }

    public static String loadConfigResource(String fileName) {
	File file = openFile(fileName);
	byte[] cBytes = CharSetConvertor.readFileToTypes(file);
	return CharSetConvertor.convertBytes(cBytes, fileName);
    }

    public static File openFile(String fileName) {
	return new File(dataDir + fileName);
    }
}