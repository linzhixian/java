package com.funugame.parkour.datacenter.service;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.funugame.parkour.api.IMatchService;
import com.funugame.parkour.api.configbeans.RefleshMatchListConfig;
import com.funugame.parkour.api.daoentity.BestScoreOne;
import com.funugame.parkour.api.daoentity.InsertMatchUser;
import com.funugame.parkour.api.daoentity.MatchUser;
import com.funugame.parkour.api.daoentity.UserInfo;
import com.funugame.parkour.api.daoentity.UserVary;
import com.funugame.parkour.dao.UserBestScoreMapper;
import com.funugame.parkour.dao.UserInfoMapper;
import com.funugame.parkour.dao.UserMatchMapper;
import com.funugame.parkour.dao.UserVaryMapper;
import com.lzx.framework.utils.DateFormatUtil;

@Service("userMatchService_RMI")
public class MatchService implements IMatchService {
    @Autowired
    private UserInfoMapper userInfoMapper;
    @Autowired
    private UserVaryMapper userVaryMapper;
    @Autowired
    private UserMatchMapper userMatchMapper;
    @Autowired
    private UserBestScoreMapper userBestScoreMapper;

    public static int LIMIT = 10;// 生成挑战用户数量

    /**
     * 获取用户挑战列表：如果为空则自动生成，如果有用户当且仅当用户都已经挑战赢了且不是今天生成的
     */
    @Override
    public List<MatchUser> getMathUserList(int uid, int chapterid) {
	List<MatchUser> userList = userMatchMapper.getMatchUserList(uid, chapterid);
	// 没有用户列表立刻生成
	if (userList.size() == 0) {
	    generateMatchUserList(uid, chapterid, false);
	    return userMatchMapper.getMatchUserList(uid, chapterid);
	}
	int winCount = 0;
/*	for (MatchUser u : userList) {
	    if (u.getResult() == 1)
		winCount++;
	    // 如果有还没比赛的立刻返回
	    if (u.getResult() == 0) {
		return userList;
	    }
	}*/
	// 如果都赢了，立刻重新生成
	if (winCount == userList.size()) {
	    return reGenerateMatchUserList(uid, chapterid);
	}
	// 判断断用户的生成时间如果是24小时前的就重新生成
	if (isRegenerateMatchList(userList.get(0).getUpdatetime())) {
	    return reGenerateMatchUserList(uid, chapterid);
	} else
	    return userList;
    }

    public static boolean isRegenerateMatchList(Date updatetime) {

	// 如果不是同一天的重新生成
	if (!DateFormatUtil.isToday(updatetime.getTime())) {
	    return true;
	}
	Calendar now = Calendar.getInstance();
	Calendar c = Calendar.getInstance();
	c.set(Calendar.MINUTE, 0);
	c.set(Calendar.SECOND, 0);
	c.set(Calendar.MILLISECOND, 0);
	int lastTime = -1;
	int nowTime = -1;
	int[] hours = RefleshMatchListConfig.getHours();
	for (int i = 0; i < hours.length; i++) {
	    int hour = hours[i];
	    c.set(Calendar.HOUR_OF_DAY, hour);
	    if (c.getTimeInMillis() >= updatetime.getTime() && lastTime == -1) {
		lastTime = i;
	    }
	    //现在时间减去10秒，以免前后端时间误差
	    if (c.getTimeInMillis() >= (now.getTimeInMillis()+10*1000) && nowTime == -1) {
		nowTime = i;
	    }
	}
	if (nowTime > lastTime) {
	    return true;
	}
	return false;
    }
    /**
     * 强制重新生成挑战进阶用户列表
     * 
     * @param uid
     * @param chapterid
     */
    public List<MatchUser> reGenerateMatchUserList(int uid, int chapterid) {
	generateMatchUserList(uid, chapterid, true);
	return getMathUserList(uid, chapterid);
    }

    /**
     * 生成挑战进阶用户列表
     * 
     * @param uid
     * @param chapterid
     * @param isDelete
     *            是否删原有用户
     */
    private void generateMatchUserList(int uid, int chapterid, boolean isDelete) {
	Map<String, Object> paraMap = new HashMap<String, Object>();
	paraMap.put("uid", uid);
	if (isDelete) {
	    userMatchMapper.deleteList(uid, chapterid);
	}

	List<BestScoreOne> resultList = new ArrayList<BestScoreOne>();
	String score = RankService.getFieldNameByChapterId(chapterid);
	String dist = RankService.getDistFieldNameByChapterId(chapterid);
	int masterscore = userBestScoreMapper.getScore(uid, score);
	// 取出比用户得分高的10个用户
	List<BestScoreOne> bList = userBestScoreMapper.getBiggerScoreUserList(uid, score, dist, LIMIT + 50);
	// 取出比用户得分低的10个用户
	List<BestScoreOne> sList = userBestScoreMapper.getSmallerScoreUserList(uid, score, dist, LIMIT + 50);
	// 分别从得分高的和低的用户列表各取一个用户，直至数量达到10个
	Set<Integer> ids = new HashSet<Integer>();
	// 随机从结果集里取10个用户
	if (bList.size() > 0 || sList.size() > 0) {
	    Random r = new Random();
	    int totalsize = bList.size() + sList.size();
	    while (true) {
		if (resultList.size() >= LIMIT)
		    break;
		if (ids.size() >= totalsize)
		    break;
		if (bList.size() == 0 && sList.size() == 0)
		    break;
		int index = 0;
		BestScoreOne b = null;
		if (bList.size() > 0) {
		    index = r.nextInt(bList.size());
		    b = bList.get(index);
		}
		if (b != null && !ids.contains(b.getUid())) {
		    if (isNearbyScore(b.getScore(), masterscore)) {
			ids.add(b.getUid());
			resultList.add(b);
		    }
		    bList.remove(index);
		    continue;
		} else {
		    if (sList.size() > 0) {
			index = r.nextInt(sList.size());
			b = sList.get(index);
			if (!ids.contains(b.getUid())) {
			    if (isNearbyScore(b.getScore(), masterscore)) {
				ids.add(b.getUid());
				resultList.add(b);
			    }
			    sList.remove(index);
			}
		    }
		}
	    }

	}

	List<InsertMatchUser> list = new ArrayList<InsertMatchUser>();
	for (BestScoreOne r : resultList) {
	    UserInfo u = new UserInfo();
	    u.setId(r.getUid());
	    UserInfo result = userInfoMapper.selectOne(u);
	    UserVary uv = this.userVaryMapper.selectOne(r.getUid());
	    InsertMatchUser mu = new InsertMatchUser();
	    mu.setUid(uid);
	    mu.setMuid(r.getUid());
	    mu.setAge(uv.getAge());
	    mu.setCuplevel(uv.getCuplevel());
	    mu.setCid(chapterid);
	    mu.setMdist(r.getDist());
	    mu.setMscore(r.getScore());
	    mu.setRolename(result.getRolename());
	    mu.setFigureurl_qq(result.getFigureurl_qq());
	    list.add(mu);
	}
	Random r = new Random();
	// 人数不够，生成机器人
	if (list.size() < LIMIT) {
	    int needCount = LIMIT - resultList.size();
	    UserVary uv = this.userVaryMapper.selectOne(uid);
	    for (int i = 0; i < needCount; i++) {
		InsertMatchUser b = new InsertMatchUser();
		b.setUid(uid);
		b.setMuid(i);
		b.setCid(chapterid);
		int age = uv.getAge() + r.nextInt(4);
		b.setAge(age);
		b.setCuplevel(uv.getCuplevel() + r.nextInt(1));
		b.setMdist(3000 + r.nextInt(10000));
		b.setMscore(masterscore + r.nextInt(5000));
		b.setRolename(UserService.generateGuestName());
		b.setFigureurl_qq(null);
		list.add(b);
	    }
	}
	if (list.size() > 0) {
	    for (InsertMatchUser muser : list) {
		userMatchMapper.insertUser(muser);
	    }
	}

    }

    private boolean isNearbyScore(Integer score, int masterscore) {
	return Math.abs(masterscore - score) <= 5000;
    }
}
